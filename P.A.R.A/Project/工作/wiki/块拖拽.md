# 块拖拽
功能点：
1. 鼠标悬浮到块的位置时，在块的左侧位置显示拖拽图标


getBlockElement 函数解析：
```
// lexical\packages\lexical-playground\src\plugins\DraggableBlockPlugin\index.tsx
getBlockElement(...) {...}
```
函数作用：在Lexical 编辑器中，根据鼠标事件的位置，找到最接近的块级元素 DOM 节点。这个函数常用于实现光标定位、拖拽插入节点等功能。

核心逻辑：查找匹配的block 元素
使用 `useEdgeAsDefault` 模式（优先匹配首尾节点）
否则 从中间索引开始查找，逐步向上下扩展

1. 确定起始索引
2. 循环查找匹配的块元素

```
let index = getCurrentIndex(topLevelNodeKeys.length);
let direction = Indeterminate;

while (index >= 0 && index < topLevelNodeKeys.length) {
  const key = topLevelNodeKeys[index];
  const elem = editor.getElementByKey(key);
  ...
}
```

**几何判断：鼠标是否落在该块元素区域内**
a. 获取鼠标点坐标
```
const point = new Point(event.x, event.y);
```
b. 获取块元素的DOM Rect 并计算 margin 折叠后的范围
```
const domRect = Rect.fromDOM(elem);
const {marginTop, marginBottom} = getCollapsedMargins(elem);
```
c. 扩展矩形区域以包含margin
```
const rect = domRect.generateNewRect({
  bottom: domRect.bottom + marginBottom,
  left: anchorElementRect.left,
  right: anchorElementRect.right,
  top: domRect.top - marginTop,
});
```
d. 判断鼠标点是否落在该区域
```
const {
  result,
  reason: {isOnTopSide, isOnBottomSide},
} = rect.contains(point);

if (result) {
  blockElem = elem;
  prevIndex = index;
  break;
}
```
- 如果命中，设置 `blockElem` 并记录 `prevIndex` 提高下次查找效率

**方向判断： 未命中时决定向上还是向下查找**

```
if (direction === Indeterminate) {
  if (isOnTopSide) {
    direction = Upward;
  } else if (isOnBottomSide) {
    direction = Downward;
  } else {
    // stop search block element
    direction = Infinity;
  }
}

index += direction;
```
根据鼠标点相对于当前块元素的位置，决定继续向上或向下查找

## 应用场景举例：
- 实现拖拽插入新节点功能时，判断用户想把节点插到哪一行
- 实现自定义悬浮菜单、光标定位等交互行为

## 依赖结构说明：
- `Point` 和 `Rect` 是自定义类，用户封装坐标和矩形判断逻辑
- `getCollapsedMargins` 处理 CSS 的 margin 折叠行为，确保判断更贴近浏览器实际渲染效果

## 总结
`getBlockElement` 是一个典型的 “基于视觉位置查找最近元素” 的算法函数，结合了：
- DOM结构遍历
- 坐标系统判断
- 性能优化策略（从中间开始查找、缓存上次命中索引）

它为编辑器提供了精准的交互定位能力。




应用： 根据鼠标位置实现节点的自定义悬浮菜单。

